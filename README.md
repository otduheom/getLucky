# GetLucky - Социальная сеть

## Описание проекта

GetLucky - это полнофункциональная социальная сеть с возможностью поиска пользователей, добавления в друзья, общения в личных чатах и управления профилем.

## Требуемый функционал

### Основные возможности:

- ✅ Поиск пользователей по ФИО или никам
- ✅ Добавление других пользователей в друзья
- ✅ Отображение друзей онлайн (зеленый индикатор)
- ✅ Личные чаты один на один с друзьями
- ✅ Отправка сообщений в реальном времени (или с обновлением)
- ✅ История сообщений в чатах

### Страницы приложения:

1. **Главная страница (`/`)**

   - 10 случайных пользователей из топ-100 популярных (больше всего друзей)
   - Карточки с фото, ФИО/ник и кнопкой "Добавить в друзья"
   - Клик по карточке → переход на личную страницу пользователя
   - Форма поиска пользователя по ФИО/нику

2. **Моя страница (`/profile` или `/profile/:userId`)**

   - Добавление/обновление фотографии профиля
   - Редактирование анкеты (имя, возраст, город и др.)
   - Список всех друзей (онлайн помечены зеленым кружочком)
   - Кнопка перехода в чат с другом

3. **Страница друзей (`/friends`)**

   - Список всех друзей (аватарка, ФИО/ник)
   - Клик по аватарке/ФИО → переход на страницу друга
   - Форма поиска по друзьям
   - Кнопка "Написать сообщение" для каждого друга

4. **Страница чатов (`/chats`)**

   - Список всех диалогов (чатов) с друзьями
   - Отображение последнего сообщения и времени
   - Индикатор непрочитанных сообщений
   - Поиск по чатам

5. **Страница чата (`/chat/:friendId`)**
   - Отображение всех сообщений с конкретным другом
   - Форма отправки нового сообщения
   - Автоскролл к новым сообщениям
   - Отметка сообщений как прочитанных

---

## План реализации

### Этап 1: Расширение модели User и базы данных ✅

#### 1.1 Миграция для расширения таблицы Users ✅

- Добавить поля в модель User:
  - `avatar` (STRING) - путь к аватару
  - `nickname` (STRING, unique) - никнейм
  - `firstName` (STRING) - имя
  - `lastName` (STRING) - фамилия
  - `age` (INTEGER) - возраст
  - `city` (STRING) - город
  - `about` (TEXT) - информация о себе
  - `lastSeen` (DATE) - время последней активности (для определения онлайн статуса)
- Обновить модель `server/db/models/user.js`

#### 1.2 Создание новых моделей

- **Friendship** (многие-ко-многим для друзей) ✅
  - `userId` (INTEGER, FK → Users.id)
  - `friendId` (INTEGER, FK → Users.id)
  - `status` (ENUM: 'pending', 'accepted', 'blocked')
  - `createdAt`, `updatedAt`
- **Message** (сообщения в чате)
  - `id` (INTEGER, PK)
  - `senderId` (INTEGER, FK → Users.id)
  - `receiverId` (INTEGER, FK → Users.id)
  - `text` (TEXT) - текст сообщения
  - `isRead` (BOOLEAN) - прочитано ли сообщение
  - `createdAt`, `updatedAt`

#### 1.3 Настройка связей (associations)

- User.belongsToMany(User, { through: Friendship, as: 'Friends', foreignKey: 'userId', otherKey: 'friendId' }) ✅
- User.hasMany(Message, { foreignKey: 'senderId', as: 'sentMessages' }) ✅
- User.hasMany(Message, { foreignKey: 'receiverId', as: 'receivedMessages' }) ✅
- Message.belongsTo(User, { foreignKey: 'senderId', as: 'sender' }) ✅
- Message.belongsTo(User, { foreignKey: 'receiverId', as: 'receiver' }) ✅

---

### Этап 2: Backend API - Профили и друзья ✅

#### 2.1 Роутер для профилей ✅

- `GET /api/profile/:userId` - получение профиля пользователя
- `PUT /api/profile` - обновление своего профиля (verifyAccessToken)
- `POST /api/profile/avatar` - загрузка аватара (verifyAccessToken)

#### 2.2 Контроллер профилей ✅

- Методы для получения и обновления профиля
- Валидация данных профиля
- Работа с файлами (multer для загрузки изображений)

#### 2.3 Роутер для друзей ✅

- `GET /api/friends` - список друзей текущего пользователя
- `GET /api/friends/popular` - топ-100 популярных пользователей (по количеству друзей)
- `POST /api/friends/request/:userId` - отправка заявки в друзья
- `PUT /api/friends/accept/:requestId` - принятие заявки
- `DELETE /api/friends/:friendId` - удаление из друзей
- `GET /api/friends/search?query=...` - поиск по друзьям
- `GET /api/friends/online` - друзья онлайн

#### 2.4 Контроллер друзей ✅

- Логика управления дружбой
- Подсчет популярности пользователей
- Определение онлайн статуса (проверка lastSeen)

#### 2.5 Роутер для поиска ✅

- `GET /api/search/users?query=...` - поиск пользователей по ФИО/нику

---

### Этап 3: Backend API - Чат (личные сообщения) ✅

#### 3.1 Роутер для сообщений (`server/src/routes/messagesRouter.js`) ✅

- `GET /api/messages/chat/:friendId` - получить все сообщения с конкретным другом
- `POST /api/messages` - отправить новое сообщение (verifyAccessToken)
- `PUT /api/messages/:messageId/read` - отметить сообщение как прочитанное (verifyAccessToken)
- `PUT /api/messages/chat/:friendId/read-all` - отметить все сообщения в чате как прочитанные (verifyAccessToken)
- `GET /api/messages/chats` - получить список всех чатов (диалогов) с последним сообщением (verifyAccessToken)
- `GET /api/messages/unread-count` - получить количество непрочитанных сообщений (verifyAccessToken)

#### 3.2 Контроллер сообщений (`server/src/controllers/MessagesController.js`) ✅

- Логика отправки и получения сообщений
- Проверка, что пользователи являются друзьями (для отправки сообщений)
- Подсчет непрочитанных сообщений
- Получение списка чатов с последними сообщениями

#### 3.3 Сервис сообщений (`server/src/services/MessagesService.js`) ✅

- Методы работы с сообщениями в БД
- Форматирование данных для отправки клиенту
- Логика получения чатов

#### 3.4 Настройка WebSocket (Socket.io) ✅

- `server/src/socket/socketHandler.js` - обработчик Socket.io соединений
- Аутентификация через JWT токен
- События: `send-message`, `mark-read`, `new-message`, `chats-updated`
- Комнаты для каждого пользователя (`user-${userId}`)
- Интеграция с HTTP сервером в `server/src/server.js`

---

### Этап 4: Backend - Middleware и утилиты ✅

#### 4.1 Обновление lastSeen ✅

- Middleware `server/src/middlewares/updateLastSeen.js` - обновление времени последней активности при каждом запросе (для авторизованных)

#### 4.2 Настройка multer ✅

- Конфигурация для загрузки изображений (`server/src/configs/multerConfig.js`)
- Ограничение размера файла, типы файлов

#### 4.3 Middleware для проверки дружбы (для чата) ✅

- `server/src/middlewares/checkFriendship.js` - проверка, что пользователи являются друзьями перед отправкой сообщений

---

### Этап 5: Frontend - Компоненты и страницы ✅

#### 5.1 Главная страница (`client/src/components/pages/MainPage.tsx`) ✅

- Компонент `PopularUsersList` - список популярных пользователей ✅
- Компонент `UserCard` - карточка пользователя (фото, ФИО/ник, кнопка "Добавить в друзья") ✅
- Компонент `UserSearchForm` - форма поиска пользователей ✅
- Использование API: `GET /api/friends/popular`, `GET /api/search/users` ✅

#### 5.2 Страница профиля (`client/src/components/pages/ProfilePage.tsx`) ✅

- Компонент `ProfileHeader` - аватар, кнопка редактирования ✅
- Компонент `ProfileEditForm` - форма редактирования анкеты ✅
- Компонент `FriendsList` - список друзей с индикатором онлайн ✅
- Компонент `MessageButton` - кнопка "Написать сообщение" для друга ✅
- Использование API: `GET /api/profile/:userId`, `PUT /api/profile`, `POST /api/profile/avatar` ✅

#### 5.3 Страница друзей (`client/src/components/pages/FriendsPage.tsx`) ✅

- Компонент `FriendsList` - список всех друзей ✅
- Компонент `FriendSearchForm` - поиск по друзьям ✅
- Компонент `FriendItem` - элемент списка (аватарка, ФИО/ник, ссылка на профиль, кнопка "Написать") ✅
- Использование API: `GET /api/friends`, `GET /api/friends/search` ✅

#### 5.4 Страница списка чатов (`client/src/components/pages/ChatsPage.tsx`) ✅

- Компонент `ChatsList` - список всех диалогов ✅
- Компонент `ChatItem` - элемент списка (аватар друга, имя, последнее сообщение, время, индикатор непрочитанных) ✅
- Компонент `ChatSearchForm` - поиск по чатам ✅
- Использование API: `GET /api/messages/chats`, `GET /api/messages/unread-count` ✅

#### 5.5 Страница чата (`client/src/components/pages/ChatPage.tsx`) ✅

- Компонент `ChatHeader` - информация о собеседнике (аватар, имя, онлайн статус) ✅
- Компонент `MessagesList` - список сообщений (с автоскроллом) ✅
- Компонент `MessageItem` - отдельное сообщение (отправленное/полученное, время) ✅
- Компонент `MessageInput` - форма отправки сообщения ✅
- Использование API: `GET /api/messages/chat/:friendId`, `POST /api/messages`, `PUT /api/messages/chat/:friendId/read-all` ✅

#### 5.6 Компоненты UI ✅

- `OnlineIndicator` - зеленый кружочек для онлайн статуса ✅
- `UserAvatar` - компонент аватара с fallback ✅
- `AddFriendButton` - кнопка добавления в друзья ✅
- `UnreadBadge` - бейдж с количеством непрочитанных сообщений ✅
- `MessageButton` - кнопка "Написать сообщение" ✅

---

### Этап 6: Frontend - API клиенты ✅

#### 6.1 API модули (`client/src/entities/`) ✅

- `profile/ProfileApi.ts` - API для профилей ✅
- `friends/FriendsApi.ts` - API для друзей ✅
- `messages/MessagesApi.ts` - API для сообщений и чатов ✅
- `search/SearchApi.ts` - API для поиска ✅

#### 6.2 Обновление роутинга (`client/src/App.tsx`) ✅

- Добавлены маршруты: ✅
  - `/friends` → FriendsPage ✅
  - `/profile/:userId?` → ProfilePage ✅
  - `/chats` → ChatsPage ✅
  - `/chat/:friendId` → ChatPage ✅

#### 6.3 Socket.io клиент ✅

- `shared/lib/socketInstance.ts` - инициализация и управление WebSocket соединением ✅

---

### Этап 7: Улучшения и оптимизация

#### 7.1 Реализация онлайн статуса ✅

- Обновление lastSeen через middleware `updateLastSeen` ✅
- Определение онлайн статуса через проверку lastSeen (lastSeen < 5 минут = онлайн) ✅
- Отображение онлайн статуса в UI через компонент `OnlineIndicator` ✅

#### 7.2 Реализация реального времени для чата ✅

- WebSocket соединение для отправки/получения сообщений в реальном времени ✅
- Реализовано через Socket.io ✅
- Обновление списка чатов при новых сообщениях ✅

#### 7.3 Пагинация

- Добавить пагинацию для списков (популярные пользователи, друзья, сообщения)
- Backend: query параметры `limit`, `offset`
- Frontend: бесконечная прокрутка или кнопка "Загрузить еще"

#### 7.4 Уведомления (частично)

- Счетчики непрочитанных сообщений ✅ (реализовано через API)
- Уведомления о новых сообщениях (можно добавить браузерные уведомления)
- Уведомления о новых заявках в друзья (можно добавить)

#### 7.5 Оптимизация

- Кэширование списка друзей
- Виртуализация списка сообщений для длинных чатов
- Оптимизация изображений аватаров

---

## Структура API Endpoints

### Авторизация (уже реализовано)

- `POST /api/auth/signup` - регистрация
- `POST /api/auth/login` - вход
- `POST /api/auth/refreshTokens` - обновление токенов

### Профили ✅

- `GET /api/profile/:userId` - получить профиль
- `PUT /api/profile` - обновить свой профиль (требует токен)
- `POST /api/profile/avatar` - загрузить аватар (требует токен)

### Друзья ✅

- `GET /api/friends` - список друзей (требует токен)
- `GET /api/friends/popular` - топ-100 популярных
- `POST /api/friends/request/:userId` - отправить заявку (требует токен)
- `PUT /api/friends/accept/:requestId` - принять заявку (требует токен)
- `DELETE /api/friends/:friendId` - удалить друга (требует токен)
- `GET /api/friends/search?query=...` - поиск по друзьям (требует токен)
- `GET /api/friends/online` - друзья онлайн (требует токен)

### Поиск ✅

- `GET /api/search/users?query=...` - поиск пользователей

### Сообщения (чат) ✅

- `GET /api/messages/chat/:friendId` - получить сообщения с другом (требует токен)
- `POST /api/messages` - отправить сообщение (требует токен)
- `PUT /api/messages/:messageId/read` - отметить сообщение как прочитанное (требует токен)
- `PUT /api/messages/chat/:friendId/read-all` - отметить все сообщения в чате как прочитанные (требует токен)
- `GET /api/messages/chats` - получить список всех чатов (требует токен)
- `GET /api/messages/unread-count` - получить количество непрочитанных сообщений (требует токен)

### WebSocket события (Socket.io) ✅

- `send-message` (клиент → сервер) - отправить сообщение через WebSocket
- `mark-read` (клиент → сервер) - отметить сообщения как прочитанные
- `new-message` (сервер → клиент) - новое сообщение получено
- `message-sent` (сервер → клиент) - подтверждение отправки сообщения
- `chats-updated` (сервер → клиент) - обновление списка чатов
- `messages-read` (сервер → клиент) - уведомление об отметке сообщений как прочитанных
- `user-online` (сервер → клиент) - пользователь подключился
- `user-offline` (сервер → клиент) - пользователь отключился

---

## Порядок реализации (рекомендуемый)

1. ✅ **Этап 1**: Расширение модели User + создание моделей Friendship и Message
2. ✅ **Этап 2**: Backend API для профилей и друзей
3. ✅ **Этап 3**: Backend API для чата + WebSocket (Socket.io)
4. ✅ **Этап 4**: Backend - Middleware и утилиты
5. ✅ **Этап 5**: Frontend - Компоненты и страницы
6. ✅ **Этап 6**: Frontend - API клиенты и роутинг
7. **Этап 7**: Улучшения (пагинация, оптимизация, уведомления)

---

## Технический стек

### Backend

- Node.js + Express
- Sequelize ORM
- PostgreSQL (предположительно)
- JWT для аутентификации
- Multer для загрузки файлов
- Socket.io ✅ (для WebSocket чата)

### Frontend

- React + TypeScript
- React Router
- Axios для HTTP запросов
- CSS Modules (судя по структуре)
- Socket.io-client (для WebSocket чата)

---

## Дополнительные заметки

- Определение популярности:

  - Сортировка по количеству принятых дружеских связей (status = 'accepted')

- Онлайн статус:

  - Проверка поля `lastSeen` пользователя
  - Если `lastSeen` < 5 минут от текущего времени → онлайн

- Отправка сообщений:

  - Сообщения могут отправлять только друзья (статус 'accepted')
  - При отправке сообщения `isRead = false`
  - При получении списка сообщений пользователем, сообщения для него помечаются как прочитанные

- Загрузка файлов:

  - Аватары сохраняются в `server/public/uploads/avatars/`
  - Имена файлов: `avatar-userId-timestamp.extension`

- Чат:
  - Диалог идентифицируется парой `senderId` и `receiverId`
  - При получении чата возвращаются сообщения, где текущий пользователь - отправитель или получатель
  - Список чатов содержит последнее сообщение и информацию о собеседнике
  - Непрочитанные сообщения - это сообщения, где `receiverId = текущий пользователь` и `isRead = false`
  - WebSocket (Socket.io) реализован для реального времени:
    - Аутентификация через JWT токен в `socket.handshake.auth.token`
    - Каждый пользователь подключается к комнате `user-${userId}`
    - Сообщения отправляются получателю через WebSocket в реальном времени
    - Автоматическое обновление списка чатов при новых сообщениях
